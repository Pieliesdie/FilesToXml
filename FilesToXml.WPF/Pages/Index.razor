@page "/"
@using FileInfo = System.IO.FileInfo
@using Size = MudBlazor.Size
@using FilesToXml.Core
@using FilesToXml.WPF.Helpers
@using FilesToXml.WPF.Model
@using System.Text
@using System.Windows
@using Microsoft.Win32
@using System.IO
@inject ISnackbar Snackbar
@using MudBlazor.Components

<MudButton HtmlTag="label"
           Variant="Variant.Filled"
           Color="Color.Primary"
           Style="height: 50px;min-width: 150px"
           StartIcon="@Icons.Material.Filled.CloudUpload"
           OnClick="UploadFiles">
    Select source file
</MudButton>

<MudDataGrid Items="@ConvertOptions.Input" Class="mt-5" Dense="false">
    <Columns>
        <HierarchyColumn T="FileUpload"/>
        <PropertyColumn Property="x => x.Name" Title="Name"/>
        <PropertyColumn Property="x => x.Path" Title="Path"/>
        <PropertyColumn Property="x => x.SizeInKb" Title="Size(kb)"/>
        <PropertyColumn Property="x => x.Extension" Title="Extension"/>
        <TemplateColumn StickyRight="true" Sortable="false">
            <CellTemplate>
                <MudIconButton Icon="@Icons.Material.Outlined.Delete" Size="@Size.Small" Color="Color.Error" OnClick="() => RemoveUpload(context.Item)"/>
            </CellTemplate>
        </TemplateColumn>
    </Columns>
    <ChildRowContent>
        <MudStack Row="false" Spacing="1" AlignItems="AlignItems.Stretch">
            <MudText Typo="Typo.body2">Input encoding</MudText>
            <MudSelectExtended SearchBox="true" ItemCollection="encodingInfo" @bind-Value="@context.Item.Encoding"
                               T="Encoding" ToStringFunc="@FriendlyEncodingString"/>
            <MudText Typo="Typo.body2">Dataset label</MudText>
            <MudTextField T="string" @bind-Value="@context.Item.Label" Variant="Variant.Text" Clearable="true"></MudTextField>
            @if (context.Item.Extension == "csv")
            {
                <MudText Typo="Typo.body2">Csv delimiter</MudText>
                <MudTextField T="string" @bind-Value="@context.Item.Delimiter" Variant="Variant.Text"></MudTextField>
            }
        </MudStack>
    </ChildRowContent>
</MudDataGrid>
<MudExpansionPanels Class="mt-5">
    <MudExpansionPanel Text="Settings">
        <MudStack>
            <MudCheckBox @bind-Checked="@ConvertOptions.DisableFormat">Disable output file formatting</MudCheckBox>
            <MudCheckBox @bind-Checked="@ConvertOptions.ForceSave">Override output file</MudCheckBox>
            <MudSelectExtended SearchBox="true" ItemCollection="encodingInfo" @bind-Value="ConvertOptions.OutputEncoding"
                               T="Encoding" ToStringFunc="@(new Func<Encoding, string>(FriendlyEncodingString))"
                               Label="Output Encoding"/>
        </MudStack>
    </MudExpansionPanel>
</MudExpansionPanels>
<MudStack Row="true" Class="mt-3" Style="max-height: 100px;" AlignItems="AlignItems.End">
    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               Style="height: 50px;min-width: 160px"
               StartIcon="@Icons.Material.Filled.Folder"
               OnClick="SelectFolder">
        Select output file
    </MudButton>
    <MudTextField FullWidth="true" T="string" @bind-Value="@ConvertOptions.Output" Label="Output file" Clearable="true"/>
    <MudSpacer/>
    <MudButton @bind-Disabled="@IsBusy"
               Variant="Variant.Filled"
               Class="pa-5"
               Style="height: 50px;min-width: 160px"
               Color="Color.Info"
               StartIcon="@Icons.Material.Filled.NotStarted"
               OnClick="SaveResult">
        Start convertation
    </MudButton>
</MudStack>
<MudExpansionPanels Style="flex:1" Class="mt-5 mb-5">
    <MudExpansionPanel Text="Logs">
        <MudContainer style="width: 100%; max-height:300px; overflow:auto" MaxWidth="MaxWidth.False">
            <Virtualize Context="message" ItemsProvider="OutputItemsProvider" ItemSize="20" @ref="outputVirtualizeComponent">
                <ItemContent>
                    <MudText Style="height:20px; white-space:pre" Typo="@Typo.body2" Color="@message.Color">@message.Content</MudText>
                </ItemContent>
                <Placeholder>
                    <p>
                        Loading&hellip;
                    </p>
                </Placeholder>
            </Virtualize>
        </MudContainer>
        @if (OutputCount > 0)
        {
            <MudStack Row="true" Class="mt-3" Style="max-height: 100px;" AlignItems="AlignItems.Center">
                <MudCheckBox Class="mr-3" Style="height: 40px"  @bind-Checked="@ScrollToBottomOnUpdate">Scroll to bottom on update</MudCheckBox>
                <MudSpacer/>
                <MudButton Style="width: 90px; height: 40px" ButtonType="ButtonType.Button" Variant="Variant.Filled" OnClick="CopyOutput">Copy</MudButton>
                <MudButton Style="width: 90px; height: 40px" ButtonType="ButtonType.Button" Variant="Variant.Filled" OnClick="ClearOutput">Clear</MudButton>
            </MudStack>
        }
    </MudExpansionPanel>
</MudExpansionPanels>

@code {

    private record Line
    {
        public Line() { }
        public Line(string content) => Content = content;
        public string Content { get; set; } = string.Empty;
        public Color Color { get; init; } = Color.Default;
    }

    private OptionsViewModel ConvertOptions { get; } = new();
    private readonly List<Line> output = [];
    private long OutputCount
    {
        get
        {
            lock (output)
            {
                return output.Count;
            }
        }
    }
    private bool IsBusy { get; set; } = false;
    private readonly Encoding[] encodingInfo = Encoding.GetEncodings().Select(x => x.GetEncoding()).ToArray();
    private Virtualize<Line> outputVirtualizeComponent = null!;
    private ValueTask<ItemsProviderResult<Line>> OutputItemsProvider(ItemsProviderRequest request)
    {
        lock (output)
        {
            var items = output.Skip(request.StartIndex).Take(request.Count).ToList();
            return new ValueTask<ItemsProviderResult<Line>>(new ItemsProviderResult<Line>(items, output.Count));
        }
    }
    private static string FriendlyEncodingString(Encoding? tuple)
    {
        return tuple is null ? string.Empty : tuple.EncodingName + " - Code page: " + tuple.CodePage;
    }
    private void UploadFiles()
    {
        var ofd = new OpenFileDialog
        {
            Multiselect = true,
            Filter = "all files|*.*|" + Enum.GetNames(typeof(SupportedFileExt)).Select(x => $"{x} files|*.{x}").Aggregate((x, y) => $"{x}|{y}")
        };

        if (ofd.ShowDialog() != true) return;

        var result = ofd.FileNames;
        if (result is null || !result.Any()) return;

        foreach (var file in result)
        {
            if (file.GetExtFromPath() is null)
            {
                Snackbar.Add($"{file} not supported", Severity.Error);
                continue;
            }

            ConvertOptions.Input.Add(new()
            {
                Path = file,
                Name = Path.GetFileNameWithoutExtension(file),
                Size = new FileInfo(file).Length
            });
        }
    }
    private void RemoveUpload(FileUpload file)
    {
        ConvertOptions.Input.Remove(file);
    }
    private void SelectFolder()
    {
        var sfd = new SaveFileDialog
        {
            Filter = "XML File (*.xml)|*.xml"
        };
        if (sfd.ShowDialog() != true) return;
        ConvertOptions.Output = sfd.FileName;
    }
    private async Task SaveResult()
    {
        try
        {
            IsBusy = true;
            if (!ConvertOptions.Input.Any())
            {
                Snackbar.Add($"Select files", Severity.Error);
                return;
            }

            ClearOutput();

            await using var resultStream = new LineStream(ConvertOptions.OutputEncoding);
            await using var errorStream = new LineStream(ConvertOptions.OutputEncoding);
            resultStream.OnWriteLines += (lines) => WriteToOutput(lines);
            //errorStream.OnWriteLines += (lines) => WriteToOutput(lines, Color.Error);
            if (string.IsNullOrWhiteSpace(ConvertOptions.Output))
            {
                Snackbar.Add($"Output folder is empty, print to logs", Severity.Warning);
            }

            var isConverted = await Task.Run(() => ConverterToXml.Convert(ConvertOptions.MapToOptions(), resultStream, errorStream));
            if (isConverted)
            {
                Snackbar.Add($"Converted to {ConvertOptions.Output ?? "logs"}", Severity.Success);
            }
            else
            {
                Snackbar.Add("Error", Severity.Error);
            }

            await ThrottledStateHasChanged();
        }
        catch (Exception ex)
        {
            WriteToOutput(ex.Message, Color.Error);
        }
        finally
        {
            IsBusy = false;
        }
    }
    private void WriteToOutput(string content, Color color = Color.Default) => WriteToOutput([content], color);
    private async void WriteToOutput(IEnumerable<string> content, Color color = Color.Default)
    {
        lock (output)
        {
            output.AddRange(content.Select(x => new Line(x) { Color = color }));
        }

        await ThrottledStateHasChanged();
    }
    private void CopyOutput()
    {
        lock (output)
        {
            Clipboard.SetText(string.Join(Environment.NewLine, output.Select(x => x.Content)));
        }
    }
    private void ClearOutput()
    {
        lock (output)
        {
            output.Clear();
        }

        _ = ThrottledStateHasChanged();
    }
    private bool ScrollToBottomOnUpdate { get; set; } = true;
    private bool isUpdatePending;
    // Throttle interval in milliseconds
    private readonly int throttleInterval = 1000;
    private async Task ThrottledStateHasChanged()
    {
        // If an update is already pending, do nothing
        if (isUpdatePending)
        {
            return;
        }

        // Set the flag to indicate that an update is pending
        isUpdatePending = true;

        try
        {
            // Delay for the specified interval
            await Task.Delay(throttleInterval);

            await outputVirtualizeComponent.RefreshDataAsync();
            // Invoke StateHasChanged after the delay
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            isUpdatePending = false;
        }
    }
}